<!DOCTYPE html>
<html lang="ru">

<head>
	<title>
		JS Theory
	</title>
	<meta http-equiv="Content-type" content='text/html;charset=UTF-8' />
	<link rel="stylesheet" href="css/main.css">
	<link rel="stylesheet" href="css/js-methods.css">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>

<body>
	<div class="wrapper">

		<header class="header">
			<div class="container">
				<h1 class="header__main-heading main-heading">JS Theory</h1>
			</div>
		</header>

		<main class="main">

			<section class="main__block block">
				<div class="container">
					<h2 class="block__heading heading">Math Methods</h2>
					<div class="block__content">
						<ul class="block__list">
							<li class="block__list-item">
								<div class="block__list-code code">Math.pow(x, y)</div>
								<div class="block__list-desc">возводит число x в степень y</div>
							</li>
							<li class="block__list-item">
								<div class="block__list-code code">Math.sqrt( )</div>
								<div class="block__list-desc">возвращает квадратный корень числа</div>
							</li>
							<li class="block__list-item">
								<div class="block__list-code code">Math.round()</div>
								<div class="block__list-desc">округляет до ближайшего целого числа</div>
							</li>
							<li class="block__list-item">
								<div class="block__list-code code">Math.ceil()</div>
								<div class="block__list-desc">округляет в большую сторону</div>
							</li>
							<li class="block__list-item">
								<div class="block__list-code code">Math.floor()</div>
								<div class="block__list-desc">округляет в меньшую сторону</div>
							</li>
							<li class="block__list-item">
								<div class="block__list-code code">.toFixed()</div>
								<div class="block__list-desc">округляет число до заданного в скобках количества знаков
									после запятой</div>
							</li>
							<li class="block__list-item">
								<div class="block__list-code code">.toPrecision()</div>
								<div class="block__list-desc">округляет число да заданного в скобках количества символов
								</div>
							</li>
							<li class="block__list-item">
								<div class="block__list-code code">Math.max()</div>
								<div class="block__list-desc">возвращает максимальное число из группы чисел <br>
									если функции ничего не передано, будет возвращено -Infinity</div>
							</li>
							<li class="block__list-item">
								<div class="block__list-code code">Math.min()</div>
								<div class="block__list-desc">возвращает минимальное число из группы чисел <br>
									если функции ничего не передано, будет возвращено Infinity</div>
							</li>
							<li class="block__list-item">
								<div class="block__list-code code">Math.abs()</div>
								<div class="block__list-desc">возвращает модуль числа</div>
							</li>
							<li class="block__list-item">
								<div class="block__list-code code">Math.random()</div>
								<div class="block__list-desc">возвращает случайное число [0, 1)</div>
							</li>
						</ul>
					</div>
				</div>
			</section>

			<section class="main__block block">
				<div class="container">
					<h2 class="block__heading heading">String Methods</h2>
					<div class="block__content">
						<ul class="block__list">
							<li class="block__list-item">
								<div class="block__list-code code">.toUpperCase</div>
								<div class="block__list-desc">производит преобразование в верхний регистр</div>
							</li>
							<li class="block__list-item">
								<div class="block__list-code code">.toLowerCase</div>
								<div class="block__list-desc">производит преобразование в нижний регистр</div>
							</li>
							<li class="block__list-item">
								<div class="block__list-code code">.substr(x, n)</div>
								<div class="block__list-desc">
									<p class="block__list-par">
										возвращает подстроку из строки
									</p>
									<p class="block__list-par">
										x - номер символа, с которого начинает отрезать
										(может принимать отрицательные значения, тогда отсчёт символа идёт с конца
										строки)
									</p>
									<p class="block__list-par">
										n - количество вырезаемых символов
										(если не указан, то будут вырезаны все символы до конца строки)
									</p>
								</div>
							</li>
							<li class="block__list-item">
								<div class="block__list-code code">.substring(x, y)</div>
								<div class="block__list-desc">
									<p class="block__list-par">
										возвращает подстроку из строки
									</p>
									<p class="block__list-par">
										x - номер символа, с которого начинает отрезать
									</p>
									<p class="block__list-par">
										y - номер символа, на котором заканчивает вырезать (символ с этим номером не
										включается)
									</p>
									<p class="block__list-par">
										если не указан, то будут вырезаны все символы до конца строки
									</p>
									<p class="block__list-par">
										если x > y, тогда substring ведёт себя так, будто они поменялись местами
									</p>
									<p class="block__list-par">
										если какой-то параметр больше длины строки, то он считается равным длине строки
										отрицательные значения приравниваются к 0
									</p>
								</div>
							</li>
							<li class="block__list-item">
								<div class="block__list-code code">.slice(x, y)</div>
								<div class="block__list-desc">
									<p class="block__list-par">
										возвращает подстроку из строки
									</p>
									<p class="block__list-par">
										x - номер символа, с которого начинает отрезать
									</p>
									<p class="block__list-par">
										y - номер символа, на котором заканчивается вырезание (символ с этим номером не
										включается)
									</p>
									<p class="block__list-par">
										если не указан, то будут вырезаны все символы до конца строки
									</p>
									<p class="block__list-par">
										может принимать отрицательные значения, тогда отсчёт символа начнётся с конца
										строки
									</p>
									<p class="block__list-par">
										если x > y, вернётся пустая строка
									</p>
								</div>
							</li>
							<li class="block__list-item">
								<div class="block__list-code code">.indexOf('…', y)</div>
								<div class="block__list-desc">
									<p class="block__list-par">
										осуществляет поиск подстроки
									</p>
									<p class="block__list-par">
										возвращает позицию первого совпадения, а если оно не найдено, вернёт -1
									</p>
									<p class="block__list-par">
										y - номер символа, с которого начинается поиск
									</p>
									<p class="block__list-par">
										если не указан, поиск идёт с начала строки
									</p>
									<p class="block__list-par">
										может принимать отрицательные значения, тогда отсчёт символа начнётся с конца
										строки
									</p>
									<p class="block__list-par">
										чувствителен к регистру символов
									</p>
								</div>
							</li>
							<li class="block__list-item">
								<div class="block__list-code code">.lastIndexOf('…')</div>
								<div class="block__list-desc">
									<p class="block__list-par">
										осуществляет поиск подстроки
									</p>
									<p class="block__list-par">
										поиск начинается с конца строки
									</p>
								</div>
							</li>
							<li class="block__list-item">
								<div class="block__list-code code">.startsWith('…')</div>
								<div class="block__list-desc">
									<p class="block__list-par">
										определяет, начинается ли строка с указанных в скобках символов
									</p>
									<p class="block__list-par">
										возвращает true / false
									</p>
								</div>
							</li>
							<li class="block__list-item">
								<div class="block__list-code code">.endsWith('…')</div>
								<div class="block__list-desc">
									<p class="block__list-par">
										определяет, заканчивается ли строка на указанные в скобках символы
									</p>
									<p class="block__list-par">
										возвращает true / false
									</p>
								</div>
							</li>
							<li class="block__list-item">
								<div class="block__list-code code">.split("x", y)</div>
								<div class="block__list-desc">
									<p class="block__list-par">
										осуществляет разбиение строки в массив по указанному разделителю "x"
									</p>
									<p class="block__list-par">
										если x не указан, вернётся вся строка
									</p>
									<p class="block__list-par">
										если он указан как пустые кавычки, то каждый символ строки попадёт в отдельный
										элемент массива
									</p>
									<p class="block__list-par">
										y - можно указать максимальное количество элементов в массиве
									</p>
								</div>
							</li>
							<li class="block__list-item">
								<div class="block__list-code code">.join("x")</div>
								<div class="block__list-desc">
									<p class="block__list-par">
										объединяет элементы массива в строку с указанным разделителем "x"
									</p>
									<p class="block__list-par">
										если разделитель не указан, то по умолчанию им станет запятая
									</p>
									<p class="block__list-par">
										если указать пустые кавычки - разделителя не будет
									</p>

								</div>
							</li>
							<li class="block__list-item">
								<div class="block__list-code code">.replaceAll('x', 'y')</div>
								<div class="block__list-desc">
									<p class="block__list-par">
										заменяет все элементы х на у
									</p>
								</div>
							</li>
						</ul>
					</div>
				</div>
			</section>

			<section class="main__block block">
				<div class="container">
					<h2 class="block__heading heading">Array Methods</h2>
					<div class="block__content">
						<ul class="block__list">
							<li class="block__list-item">
								<div class="block__list-code code">.push()</div>
								<div class="block__list-desc">
									<p class="block__list-par">
										добавляет неограниченное количество новых элементов в конец массива
									</p>
								</div>
							</li>
							<li class="block__list-item">
								<div class="block__list-code code">.unshift()</div>
								<div class="block__list-desc">
									<p class="block__list-par">
										добавляет неограниченное количество новых элементов в начало массива
									</p>
								</div>
							</li>
							<li class="block__list-item">
								<div class="block__list-code code">.shift()</div>
								<div class="block__list-desc">
									<p class="block__list-par">
										удаляет первый элемент из массива
									</p>
									<p class="block__list-par">
										исходный массив изменяется, а результатом метода возвращается удалённый элемент
									</p>
								</div>
							</li>
							<li class="block__list-item">
								<div class="block__list-code code">.pop()</div>
								<div class="block__list-desc">
									<p class="block__list-par">
										удаляет последний элемент из массива
									</p>
									<p class="block__list-par">
										исходный массив изменяется, а результатом метода возвращается удалённый элемент
									</p>
								</div>
							</li>
							<li class="block__list-item">
								<div class="block__list-code code">.slice(x, y)</div>
								<div class="block__list-desc">
									<p class="block__list-par">
										вырезает и возвращает указанную часть массива
									</p>
									<p class="block__list-par">
										x - номер элемента массива, с которого начинается вырезание
									</p>
									<p class="block__list-par">
										y - номер элемента, на котором закончится вырезание (элемент не включается)
									</p>
									<p class="block__list-par">
										если не указан, то подмассив возьмётся с первого параметра до конца массива
									</p>
									<p class="block__list-par">
										может принимать отрицательные значения, тогда отсчёт начнётся с конца массива
									</p>
									<p class="block__list-par">
										метод НЕ ИЗМЕНЯЕТ исходный массив
									</p>
								</div>
							</li>
							<li class="block__list-item">
								<div class="block__list-code code">.splice(x, y, …,)</div>
								<div class="block__list-desc">
									<p class="block__list-par">
										удаляет и добавляет элементы массива, или и то и другое одновременно
									</p>
									<p class="block__list-par">
										ИЗМЕНЯЕТ сам массив и возвращает при этом массив удалённых элементов
									</p>
									<p class="block__list-par">
										x - номер элемента, который нужно удалить
									</p>
									<p class="block__list-par">
										y - количество удаляемых элементов
									</p>
									<p class="block__list-par">
										затем через запятую идут элементы, которые нужно добавить в массив, эти элементы
										добавятся вместо удалённых
									</p>
								</div>
							</li>
							<li class="block__list-item">
								<div class="block__list-code code">.indexOf(x, y)</div>
								<div class="block__list-desc">
									<p class="block__list-par">
										возвращает первый номер элемента, по которому этот элемент может быть найден в
										массиве, или -1, если такого элемента нет
									</p>
									<p class="block__list-par">
										x - искомый элемент в массиве
									</p>
									<p class="block__list-par">
										y - индекс, с которого начинается поиск
									</p>
									<p class="block__list-par">
										если x ≥ длине массива, то возвращается -1, что означает, что массив не
										просматривается
									</p>
								</div>
							</li>
							<li class="block__list-item">
								<div class="block__list-code code">.includes()</div>
								<div class="block__list-desc">
									<p class="block__list-par">
										проверяет наличие элемента в массиве, возвращает true / false
									</p>
								</div>
							</li>
						</ul>
					</div>
				</div>
			</section>

			<section class="main__block block">
				<div class="container">
					<h2 class="block__heading heading">Iterating Methods</h2>
					<div class="block__content">

						<article class="block__article article">
							<h3 class="article__heading">МЕТОД <span class="code">map</span></h3>
							<div class="article__content">
								<p class="article__par">• Предназначен для преобразования массива</p>
								<p class="article__par">• Метод <span class="code">map</span> принимает параметром
									функцию
									коллбэк, а затем возвращает изменённый массив</p>
								<pre class="article__code code">
let arr = [1, 2, 3, 4, 5];

let result = arr.map(<b>function () {
	
	}
</b>
);
														</pre>
								<p class="article__par">
									• Если в коллбэке указать 1-й параметр (с любым именем), то в него автоматически
									будут
									попадать значения элементов
									массива
								</p>
								<pre class="article__code code">
let arr = [1, 2, 3, 4, 5];

let result = arr.map(function(<b>elem</b>) {
	console.log(elem);
}
);
														</pre>
								<p class="article__par">
									• Преобразованный массив запишется в переменную result
								</p>
								<p class="article__par">
									• В этом массиве будет такое же количество элементов, как и в исходном, но значения
									будут другими
								</p>
								<p class="article__par">
									• Для каждого элемента вместо исходного значения будет стоять то значение, которое
									вернул для него вызов коллбэка
								</p>
								<pre class="article__code code">
let arr = [1, 2, 3, 4, 5];

let result = arr.map(function(elem) {
	return elem ** 2;
}
);

console.log(result); <span class="comment">// [1, 4, 9, 16, 25]</span>
														</pre>
								<p class="article__par">
									• Функция-коллбэк может также принимать 2-й параметр — ключ элемента массива
								</p>
								<pre class="article__code code">
let arr = [1, 2, 3, 4, 5];

let result = arr.map(function(elem, <b>index</b>) {
	return elem * index;
}
);
														</pre>
								<p class="article__par">
									или с помощью стрелочной функции
								</p>
								<pre class="article__code code">
let result = arr.map((elem, index) <b>=></b> elem * index);
														</pre>
								<p class="article__par">
									• Перебор многомерных массивов
								</p>
								<pre class="article__code code">
let arr = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];

let result = arr.map(function(elem) {
	return elem.map(function(num) {
		return num ** 2;
	})
});
								</pre>
							</div>
						</article>

						<article class="block__article article">
							<h3 class="article__heading">МЕТОД <span class="code">forEach</span></h3>
							<div class="article__content">
								<p class="article__par">
									• Работает так же, как и метод <span class="code">map</span>, только не возвращает
									изменённый массив, а просто вызывает функцию-коллбэк для
									каждого элемента массива
								</p>
								<pre class="article__code code">
let arr = ['a', 'b', 'c', 'd', 'e'];

arr.forEach(function(elem) {
	document.write(elem + '< br >')
});
								</pre>
								<p class="article__par">
									во второй параметр попадают ключи элементов
								</p>
								<pre class="article__code code">
arr.forEach(function(elem, index) {
	document.write(index + '. ' + elem + '< br >')
});
								</pre>
							</div>
						</article>

						<article class="block__article article">
							<h3 class="article__heading">МЕТОД <span class="code">filter</span></h3>
							<p class="article__par">
								• Позволяет отфильтровать элементы массива
							</p>
							<p class="article__par">
								• Параметром получает функцию-коллбэк, которая выполнится для каждого элемента массива
							</p>
							<p class="article__par">
								• Результатом filter возвращает новый массив, в который войдут только те элементы, для
								которых коллбэк вернёт true
							</p>

							<pre class="article__code code">
let arr = [1, 2, 3, 4, 5, 6];

let result = arr.filter(function(elem){
	if (elem % 2 == 0){
		return true;
	} else {
		return false;
	}
});

console.log(result);
							</pre>
							<p class="article__par">или</p>
							<pre class="article__code code">
let result2 = arr.filter(function(elem){
	return elem % 2 == 0;
});
console.log(result2);
								</pre>
							<p class="article__par">или</p>
							<pre class="article__code code">
let result3 = arr.filter(elem => elem % 2 == 0);

console.log(result3);
								</pre>
							<p class="article__par">• Подсчёт количества чётных элементов</p>
							<pre class="article__code code">
let arr = [1, 2, 3, 4, 5, 6];

let filtered = arr.filter(elem => elem % 2 == 0);
console.log(filtered.length);
							</pre>

						</article>

						<article class="block__article article">
							<h3 class="article__heading">МЕТОД <span class="code">every</span></h3>
							<p class="article__par">
								• Проверяет элементы массива и возвращает true, если для всех элементов массива коллбэк
								вернул true, в противном случае
								метод возвращает false
							</p>
							<pre class="article__code code">
let arr = [2, 4, 6, 8];

let result = arr.every(function (elem) {
	return elem % 2 == 0;
});

console.log(result);
							</pre>
						</article>

						<article class="block__article article">
							<h3 class="article__heading">Метод <span class="code">some</span></h3>
							<p class="article__par">
								• Проверяет элементы массива и возвращает true, если хотя бы для одного элемента коллбэк
								вернул true, в противном случае
								метод возвращает false
							</p>
							<p class="article__par">
								• проверка, что в массиве есть хотя бы одно чётное число:
							</p>
							<pre class="article__code code">

let arr = [1, 3, 5, 4, 7];

let res = arr.some(function(elem) {
	return elem % 2 == 0;
})

console.log(res); <span class="comment">// true	</span>						</pre>
						</article>

					</div>
				</div>
			</section>

			<section class="main__block block">
				<div class="container">
					<h2 class="block__heading heading"><span class="code">SPREAD</span> and <span
							class="code">REST</span>operators</h2>
					<div class="block__content">

						<article class="block__article article">
							<h3 class="article__heading">Оператор spread</h3>
							<p class="article__par">• Когда оператор spread стоит перед массивом, он разделяет этот
								массив на отдельные значения, превращая массив в набор
								параметров, необходимых для вызова функции</p>
							<p class="article__par">• Пусть есть функция, принимающая 3 параметра и возвращающая их
								сумму, и массив из трёх элементов</p>
							<pre class="article__code code">
function f(x, y, z) {
	return x + y + z;
}

let arr = [1, 2, 3]

f[arr];	<span class="comment">// в этом случае весь массив попадёт в первый параметр функции, а в этот параметр надо передать число, и в остальные
	параметры тоже:
</span>
f(arr[0], arr[1], arr[2]);
							</pre>
							<p class="article__par">или с помощью оператора <span class="code">spread:</span></p>
							<pre class="article__code code">
f(...arr);
console.log(f(...arr)); //6
							</pre>
							<p class="article__par">
								• можно также передать параметрами в функцию несколько массивов или и числа и массивы:
							</p>
							<pre class="article__code code">
func(...[1, 2], ...[3, 4, 5]);

func(1, 2, ...[3, 4, 5]);
							</pre>
							<p class="article__par">
								• оператор <span class="code">Math.max</span> можно применять только к списку чисел и
								нельзя к массивам, используя
								оператор <span class="code">spread</span>, можно
								разделять этот массив и находить максимальное или минимальное значения элементов массива
							</p>
							<pre class="article__code code">
function getRandomInt(min, max) {
	return Math.floor(Math.random() * (max - min + 1)) + min;
}

let arr = [];
(function fillArr(arr) {
	for (let i = 0; i < 10; i++) { 
		let x=getRandomInt(-10, 10); 
		arr.push(x) 
	} 
	return arr; 
})(arr) 
console.log(arr);
console.log(Math.max(...arr)); 
console.log(Math.min(...arr));
							</pre>

						</article>

						<article class="block__article article">
							<h3 class="article__heading">Оператор <span class="code">spread</span> и слияние массивов
							</h3>
							<p class="article__par">• Пусть есть два массива</p>
							<pre class="article__code code">
let arr1 = ['a', 'b', 'c'];
let arr2 = [1, 2, 3];
							</pre>
							<p class="article__par">
								• Чтобы элементы из одного массива встроились в другой массив, нужно у второго массива в
								месте, куда нужно встроить
								элементы первого массива прописать оператор spread и первый массив
							</p>
							<pre class="article__code code">
arr2 = [1, ...arr1, 2, 3];
console.log(arr2); <span class="comment">// [1, 'a', 'b', 'c', 2, 3]</span>
							</pre>

						</article>

						<article class="block__article article">
							<h3 class="article__heading">Оператор <span class="code">spread</span> для строк и чисел
							</h3>
							<p class="article__par">• оператор spread разбивает строку в символы через запятую</p>
							<p class="article__par">• результат такого разбиения можно передать в параметры функции</p>
							<pre class="article__code code">
function f(s1, s2, s3, s4, s5) {
	return s1 + '-' + s2 + '-' + s3 + '-' + s4 + '-' + s5;
}

console.log(f(...'abcde')); <span class="comment">// a-b-c-d-e</span>
							</pre>
							<p class="article__par">
								• можно преобразовать этот результат в массив
							</p>
							<pre class="article__code code">
let arr = [...'abcde'];
console.log(arr); <span class="comment">// ['a', 'b', 'c', 'd', 'e']</span>
							</pre>
							<p class="article__par">
								• Оператор spread не применим к числам
							</p>
							<pre class="article__code code">
let arr = [...12345]; // будет ошибка
							</pre>
						</article>

						<article class="block__article article">
							<h3 class="article__heading">Оператор <span class="code">rest</span></h3>
							<p class="article__par">
								• Оператор "..." в зависимости от места в коде может называться либо оператором <span
									class="code">spread</span>, либо оператором <span class="code">rest</span>
							</p>
							<p class="article__par">
								• Если в функцию с двумя параметрами передать больше параметров, ошибки не будет, но
								оператор rest позволит получить все
								лишние параметры в виде массива, для этого в функцию добавляется ещё один параметр
								(обязательно последним), перед
								которым пишутся три точки:
							</p>
							<pre class="article__code code">
function f(a, b, ...rest) {
	console.log(a);
	console.log(b);
	console.log(rest);
}
							</pre>
							<p class="article__par">
								• Эти три точки и есть оператор <span class="code">rest</span>, а имя переменной может
								быть любое, но обычно принято назвать "rest"
							</p>
							<pre class="article__code code">
f(1, 2, 3, 4, 5) //выведет 1; 2; [3, 4, 5]
							</pre>
							<p class="article__par">
								• Если лишних параметров не будет, в переменную <span class="code">rest</span> запишется
								пустой массив
							</p>
							<p class="article__par">
								• В функции вообще может не быть параметров, но при этом в неё можно добавить <span
									class="code">rest</span>. В этом случае функцию можно будет
								вызвать с любым количеством параметров, и все они попадут в массив rest:
							</p>
							<pre class="article__code code">
function f(...rest) {
	console.log(rest);
}

f(1, 2, 3, 4, 5) 	<div class="comment">// [1, 2, 3, 4, 5]</div>
							</pre>
						</article>

						<article class="block__article article">
							<h3 class="article__heading">
								Применение операторов <span class="code">spread</span> и <span class="code">rest</span>
							</h3>
							<p class="article__par">
								• Функция, которая будет принимать параметрами произвольное количество чисел и
								возвращать их сумму
							</p>
							<pre class="article__code code">
function getSum(...nums) {
	let sum = 0;
	for (let num of nums) {
		sum += num;
	}
	return sum;
}

let res = getSum(1, 2, 3);
console.log(res); <span class="comment">	// 6</span>
							</pre>
							<p class="article__par">
								• функция, которая принимает параметрами произвольное количество числе и возвращает их
								среднее арифметическое
							</p>
							<pre class="article__code code">
function getAvrg(...nums) {
	let sum = 0;
	for (let num of nums) {
		sum += num;
	}
	return +(sum / nums.length).toFixed(2);
}

console.log(getAvrg(2, 3, 5));
							</pre>
							<p class="article__par">
								• Функция, сливающая массивы в двухмерный
							</p>
							<pre class="article__code code">
function unite(...arrs) {
	return arrs;
}

console.log(unite([1,2,3], [4,5,6]));	<span class="comment"> // [[1, 2, 3], [4, 5, 6]]</span>
							</pre>
							<p class="article__par">
								• Функция, сливающая массивы в один
							</p>
							<pre class="article__code code">
function merge(...arrs) {
	return [].concat(...arrs)
}

let result = merge(
	[1, 2, 3], [4, 5, 6], [7, 8, 9]
)

console.log(result); 	<span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
							</pre>
						</article>

					</div>
				</div>
			</section>

		</main>

	</div>

	<script src="js/js-methods.js"></script>
</body>


</html>